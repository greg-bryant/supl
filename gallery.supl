gallery.supl

order your considerations

---------------------------

.sequence 'gallery app'

------------------

These are the aspects which connect and define the app:

a configuration for the platform
the server:
 a storage facility
 a cycle of access to storage on the server
the client (in our case delivered by the server):
 a cycle of commands on the client
 a display of those commands
 a styling of those displays

Some of these are things which, even if trivial, have default values, 
so ignoring them is not necessarily keeping them out of the picture.

------------------

.step 1 'minimal stubs'

---------

.p 'start'
.nt 'platform config'
.nt 'server'
.nt 'server client bridge'
.nt 'client'
.nt 'client style'

------------------

.step 2 'minimal end-to-end code'

---------

.p 'platform config' 'app.yaml'

---
.nt 'platform config values'
<<<

application: gallery
version: 1
runtime: python27
api_version: 1
threadsafe: true

>>>
---

---
.nt 'platform config handlers'
<<<

handlers:
- url: /main\.js
  static_files: main.js
  upload: main\.js
  secure: always
  redirect_http_response_code: 301
- url: /main\.css
  static_files: main.css
  upload: main\.css
  secure: always
  redirect_http_response_code: 301
- url: /.*
  script: gallery.app
  secure: always
  redirect_http_response_code: 301

>>>
---

---------

.p 'server' 'gallery.py'

---
.nt 'server includes'
<<<

# gallery.py

import os
import cgi
import webapp2
import logging 
import datetime
import time
import re
import base64
import urllib
import random
import hashlib
import unicodedata

from google.appengine.ext import db
from google.appengine.ext.webapp import template
from google.appengine.api import users

>>>
---

---

.nt 'server schema'
<<<

# DB Schema -- to do

>>>
---

---
.nt 'server delivers client'
<<<

class MainPage(webapp2.RequestHandler):
    def get(self):

    	template_values = {
    	}

    	path = os.path.join(os.path.dirname(__file__), 'index.html')
    	self.response.out.write(template.render(path, template_values))

>>>
---

---
.nt 'server db crud cycle'
<<<

# access API - to do

>>>
---

---
.nt 'server demux'
<<<

app = webapp2.WSGIApplication(
                                     [('/', MainPage)],
                                            debug=True)

>>>
---


---------

.p 'server client bridge' 'index.html'

---
.nt 'to launch javascript'
<<<

<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
        <title>gallery</title>
        <script type="text/javascript" charset="utf-8" src="main.js"></script>
        <link type="text/css" rel="stylesheet" href="main.css"/>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    </head>
    <body onload="main_init()">
        <div class="whole">
            <div id="header">initial text</div>
        </div>
    </body>
</html>

>>>
---
---------

---------
.p 'client' 'main.js'

---
.nt 'client central handler / event loop'
<<<

var event_queue = [];
var the_event = null;

function main_init() {
	 event_queue.push({'name':'main_page','delay':2000});
	 central_handler();
}

function main_page() {
	 $('#header').html("Main Page");
}

// CENTRAL_HANDLER:
//  called by onload and setTimeout
function central_handler() {

    if (!(event_queue.length > 0)) {
      return;
    }
    the_event = event_queue.shift();

    // call event
    window[the_event.name]();

    // only loop until the stack is empty
    if (event_queue.length > 0) {
       setTimeout(function () {central_handler();},
       			     the_event.delay);
    }
}

>>>
---

---
.nt 'client crud'
<<<
	// api use - to do
>>>
---

---
.nt 'client display'
<<<
	// display data - to do
>>>
---
---------

---------
.p 'client style' 'main.css'

---
.nt 'heading'
<<<

body {
  margin: 25px;
  background-color: rgb(240,240,240);
  font-family: arial, sans-serif;
  font-size: 12px;
}

h1 {
  font-size: 24px;
  font-weight: bold;
  margin-top: 10px;
}

/* classes */
.whole { color: white; 
       	 height: 100%;
	 width: 100%;
}

/* ids */
#header { color: purple;
	  font-size: 24px;
  	  font-weight: bold;
	 }

>>>
---

---
.nt 'display style'
---

---------

------------------

.step 3 'data'

---------

.p 'server schema'

a gallery is 
a splash page (optional)
linked to a set of thumbnail pages (with captions)
linked to photo pages
so the db: one type

photo, with caption text, and generated thumbnail.

.nt 'photo schema'
<<<
class Photo(db.Model):
    caption = db.StringProperty()
    image = db.BlobProperty()
    url = db.StringProperty(multiline=True)
    timestamp = db.DateTimeProperty(auto_now_add=True)

>>>

.nt 'more schemas'
<<<

# stub for later schemas

>>>

---------

---------
.p 'server db crud cycle'

.nt 'create'
<<<

class createPhoto(webapp2.RequestHandler):
    def post(self):

        imgdata = self.request.get('imgdata')
        caption = self.request.get('caption')
        adjusted_url = 'uploaded_' + str(time.time()) 

        photo = Photo()
        photo.image = db.Blob(images.resize(imgdata,500,378,allow_stretch=True))
        photo.url = adjusted_url
	photo.caption = caption
        photo.put()

        self.response.out.write("GOOD")
        return

>>>

.nt 'read one'
<<<
class getPhoto(webapp2.RequestHandler):
    def get(self,string):

        uncoded = urllib.unquote(string)
        adjusted = string.replace('%2F','/')
        result = db.GqlQuery("SELECT * FROM Photo WHERE key = :1 LIMIT 1",
                    adjusted).fetch(1)
        if (len(result) > 0):
            self.response.headers['Content-Type'] = 'image/png'
            self.response.out.write(result[0].image)
        else:
            photo = Photo()
            photo.image = db.Blob(urlfetch.Fetch(uncoded).content)
            photo.url = adjusted
            photo.put()

            self.response.headers['Content-Type'] = 'image/png'
            self.response.out.write(photo.image)
>>>

.nt 'read list'
<<<
class getPhotoList(webapp2.RequestHandler):
    def get(self):

        photos = db.GqlQuery("SELECT * FROM Photo")
        return_string = '['
        overview = '{ \'name\':\'photos\','
        overview = overview + '\'value\':\'\' }'
        return_string = return_string + overview

        all_n = '[' + overview
        k = 0
        i = 0
        for p in photos:

            if i > 0:
	                return_string = return_string + ','
            return_string = return_string + '{ \'name\':' + '\'' + re.escape(c.name) + '\','
            return_string = return_string + '\'key\':' + '\'' + str(c.key()) + '\' }'
            i = i + 1

        return_string = return_string + ']'   
        all_n = all_n + ']'
        if string == 'cn':
            return_string = all_n
        logging.debug(return_string)
        return return_string
        self.response.write(return_string)




>>>


.nt 'updateCaption'
<<<

class updateCaption(webapp2.RequestHandler):
    def get(self,string,caption):

       key = Photo.get(string)
       key.caption = caption
       key.put()


>>>

.nt 'delete'
<<<

class deletePhoto(webapp2.RequestHandler):
    def get(self,string):

       key = Photo.get(string)
       key.delete()

>>>

---------


---------
.p 'server demux'

.nt 'demux two'
<<<

app = webapp2.WSGIApplication(
                                     [('/', MainPage),
				     ('/CreatePhoto/',createPhoto),
				     ('/photoListGet/',getPhotoList),
				     ('/photoGet/(.*)',getPhoto),
				     ('/updateCaption/(.*)',updateCaption),
				     ('/deletePhoto/(.*)',deletePhoto)],
                                            debug=True)

>>>


---------

------------------

------------------

.step 5 'client fetch'

---------

.p 'client crud'

.nt 'ajax routines'
<<<

// maybe separate nts
// get list

// iterate through list to construct  photos html

// caption crud 



>>>

.nt 'data access layer?'
<<<


>>>


---------

------------------

------------------

.step 6 'client UX'


---------

.p 'client display'

.nt 'initial fetch'

.nt 'clickables'

.nt 'photo display'

.nt 'editing'

---------


---------

.p 'display style'

---------

------------------

.step 5 'authentication and roles'

------------------

.step 6 'ungenerate infrastructure'

The generative approach to DB ETL (extract, transform, load).
Need to be able to retrieve so you can regenerate and repopulate.

------------------

.step 7 'dashboards'

------------------


otherwise the todo lists get lost, and we're only left with artifacts, and no way to correct the lists for people who follow us. which is a bit like not saving or showing or improving your work.