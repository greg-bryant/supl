x = done
* = to do

x get c working
x get make working
x get git working
x get c writing files
x get lex working
x get yacc working
x make a supl file generator
* write gallery app as a python-javascript-css app sequence generated by supl

------------------

We're trying to make it possible to find good. we're assuming that, no
matter how much the conceptual or symbolic dominance of a tool, even this one,
it will be the judgment of natural structure, smooth unfolding, and natural 
processs that we need to facilitate, if the tool is to help us improve what we do,
make it better, increase its quality ... and explain the good to others. 

Unfolding finds platform problems. Which means it can lead us to better languages, 
better ideas, better documentation, better computation. It can also provide an 
experimental rigging for discovery of the nature of cognition in engineering. 
It can also then help to provide a standard for explanation
necessary for programs that are automatically generated.

------------------
NOTES:

Good things:

1) an early quote/snippet in an .nt 'x' makes quite a lot of sense,
   because 'x' will next appear as a .p 'x', which can then have many more refined
   definitions. This is brilliant for unfolding.

2) very different from the 'boilerplate' approach of, say, jsfiddle.

MAYBE needed things:

1) A way to rewrite X (a,b) as Y (c,d). This would bring it close to
   a context sensitive grammar rewrite system like grogix.

2) And a way to, still, make gestalt changes relative to a particular
   aspect such as this one. In the meantime, I'll use backwards-inserted
   stubs, and see how far it goes. Because we are recreating and regenerating
   the program from this description continually. Not just 'recompiling' --
   we're re-writing the code.

   In some ways, it makes it better not to be able to insert / delete 
   nodes and quotes and files.

3) The pizazz of a javascript IDE that could let you highlight deductive
   paths and holistic steps alternatively.

4) and I don't really see a downward deductive tree to match the upward
   definition fulfillment. That is, I should be able to define X and then
   use X everywhere. Since everything is a definition, nothing is a 'use'.
   That's not the point here, but it would be interesting to combine that
   m4-ish quality with these stepwise and multiple-file qualities.

------------------
